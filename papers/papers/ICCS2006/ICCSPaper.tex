	% Lecture Notes in Computer Science Latex2e Style file,
% ftp://ftp.springer.de/pub/tex/latex/llncs/latex2e/llncs2e.zip
%
% $Revision$
% $Date$
% $Log$
% Revision 1.8  2005/12/14 17:19:31  jonblower
% Near-complete first draft, plus references
%
% Revision 1.7  2005/12/14 14:50:52  abharrison
% first stab a web service sections
%
% Revision 1.6  2005/12/14 14:01:29  jonblower
% Added stuff on command-line clients
%
% Revision 1.5  2005/12/14 10:13:32  abharrison
% intro bit the web services section
%
% Revision 1.4  2005/12/14 09:17:20  jonblower
% Continued development
%
% Revision 1.3  2005/12/13 17:59:24  jonblower
% Added introductory material and the SGS namespace
%
% Revision 1.2  2005/12/13 15:28:22  jonblower
% Initial import
%

\documentclass{llncs}
%
\begin{document}
%
\title{Styx Grid Services: Lightweight, easy-to-use middleware for e-Science workflows}
%
\titlerunning{Styx Grid Services}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Jon Blower\inst{1} \and Andrew Harrison\inst{2}
\and Keith Haines\inst{1} \and Ed Llewellin\inst{3}}
%
\authorrunning{J. Blower et al.}   % abbreviated author list (for running head)
%
%%%% modified list of authors for the TOC (add the affiliations)
\tocauthor{Jon Blower (University of Reading),
Andrew Harrison (University of Cardiff),
Keith Haines (University of Reading),
Ed Llewellin (University of Cambridge)}
%
\institute{Reading e-Science Centre, Environmental Systems Science Centre,
University of Reading, Reading RG6 6AL, UK\\
\email{jdb@mail.nerc-essc.ac.uk},\\
\and
University of Cardiff, Cardiff, UK
\and
University of Cambridge, Cambridge UK}

\maketitle              % typeset the title of the contribution

\begin{abstract}
(70-150 words)
\end{abstract}
%
\section{Introduction}
There is much current interest in the use of Service-Oriented Architectures (SOAs) in scientific computing.  A key tenet of the SOA paradigm is that one can expose resources such as data stores, computing resources, sensors and computer programs as {\em services\/} that are available for access through the Internet.  Each service is independent from all other services and, indeed, the services can be managed by any number of {\em service providers\/}.  The end user (e.g.\ the scientist) can perform complex, distributed tasks by composing these services into {\em workflows\/}.  In this paper we shall focus on the issue of exposing existing computer programs as services and creating workflows from these services.  However, many of the methods we discuss could be applied to other types of resource.

In many scientific fields, the community in question has produced useful pieces of code that have been tried and tested over a substantial period of time (these programs are often termed ``legacy'' codes).  It is usually not practical for the code to be re-written and so a common task, addressed by many e-Science projects (e.g.\ REFs) is to create software that ``wraps'' an existing piece of code as some kind of Internet service, for example a Web Service (e.g.\ Soaplab, REF), OGSI Grid Service (e.g.\ GEMLCA, REF) or WS-Resource (e.g.\ WEDS, REF).  These systems are not just useful for legacy codes: newly-written code can also be be exposed as a service.  In this way, the writing of the code is divorced from the procedure of creating the service.  There are many reasons for wishing to expose a program as a service:
\begin{itemize}
	\item The code must run on a powerful resource (e.g.\ a compute cluster) but users want to access the code from a more modest machine, such as a laptop.
	\item The code is tied to a particular platform (e.g. 64-bit Solaris) but users want to access the code from other platforms.
	\item The code has many dependencies (on particular versions of libraries for example) and the exposure of the code as a service removes the need for users to install all these dependencies.
	\item The code depends on data from a large data archive and so should run on a machine that is close to the archive.  However, users want to run the code from anywhere on the Internet.
	\item The code is useful to a wide community and the provision of the code as a service removes the need for multiple users to install it locally.
\end{itemize}

Despite these benefits, in many scientific fields there are still few examples of genuinely useful, widely-available Internet services that scientists can access.  (In this paper we use the term ``Internet services'' as an umbrella term to cover Web Services, Grid Services, WS-Resources and other services that are accessible over the Internet.)  As noted in (WEDS and MOAN), this is partly due to the technical difficulty in creating many types of service, which is why the aforementioned wrapper systems have been developed.  A ``critical mass'' of useful services is required to exist before other potential service providers perceive that it is worth their time and effort to add services of their own; this is a chicken-and-egg situation.

\subsection{Problems with Web Services-based distributed systems}\label{sec:wsproblems}
Although the above wrapper systems undoubtedly make the job of creating services much easier than would otherwise be the case, we believe that further progress can be made towards increasing the ease of both creating and using Internet services.  One key issue is the nature of the services themselves.  Most e-Science projects employ Web Services (or some variant) as the core service type.  While this certainly brings many benefits (see Sect.~\ref{sec:webservices}), it also brings problems in some cases.  A common problem is that of data transfer: Web Services produce and consume XML documents, but it is undesirable to encode anything but a trivial amount of data in XML due to the time and resource required to perform this encoding and the resulting increase in the data volumes (REF).  When creating Web Services that deal with moderate or large data volumes, it is common to use a different transport mechanism for the data inputs and outputs, using the exchange of XML documents simply as a control mechanism (e.g.\ ~\cite{Woolf:2003,blower:2005}).  The need to use two different server systems (the Web Services server and the data server) increases the complexity of the system.

Another common issue arises when creating services that represent long-running programs.  In these cases it is desirable to incorporate a mechanism for notifying clients of the progress of the program and when it has completed.  The Web Services Resource Framework (WS-RF,~\cite{wsrf}) specifies a method for achieving this (WS-Notification,~\cite{wsrf-notification}), but it, like other preceding notification mechanisms (e.g.\ OGSI), suffers from a serious problem.  In order to receive notifications of progress, status etc., the client usually has to run a server process that listens for incoming progress messages (``callbacks'').  However, if the client is behind a firewall that blocks incoming connections on the port(s) in question, these messages will never be received and, what is worse, the client may never know why.  Similar problems are faced with clients that are behind Network Address Translation (NAT) routers.  In many situations the user has no control over the firewall or NAT settings and so these notification mechanisms are often defeated.

Something about problems with modelling programs as RPCs?

In this paper we shall describe a new type of Internet service called the {\em Styx Grid Service\/} or SGS.  The SGS architecture addresses the above problems, as well as providing other benefits.  A key feature is that it is very easy to create Styx Grid Services that wrap existing programs: we believe that it is significantly easier than using any of the above wrapper systems.  It is also very easy to use Styx Grid Services: the architecture is designed so that any SGS can be run from the command line {\em exactly as if it were a local program\/}.  Workflows can therefore be created using simple shell scripts (or batch files in Windows).  Alternatively, the SGS API allows the creation of custom client programs and integration with many different workflow systems.  We shall demonstrate how Styx Grid Services can interoperate with other types of Internet services such as Web Services and WS-Resources.

%
\section{The Styx Grid Services system}
\subsection{Background}
The key aims of the Styx Grid Services system are to create services that are as easy as using local programs and to allow these services to be composed easily into efficient workflows.  The design of the system is heavily influenced by that of the Inferno~\cite{Inferno} and Plan~9~\cite{Plan9} operating systems, in which local and remote resources are treated {\em identically\/}.  This is achieved because of the following two facts: (1) All resources are virtualized as a file or set of files (just as Unix variants often represent the mouse as the file {\tt /dev/mouse}); (2) all communication is performed using a file-sharing protocol.  Applications do not know whether they are operating on local or remote resources: the routing of messages is handled by the underlying operating system.

The file-sharing protocol used in Inferno is called {\em Styx\/}; Plan~9 uses an identical protocol called {\em 9P\/} (the latest version of Styx is also known as 9P2000).  Styx has a long history and was invented by the original developers of Unix~\cite{Pike:1999}.  It has several major advantages.  Styx only needs to operate on files and so it has a very small command set (13 commands) with well-defined semantics, many of which will be familiar to most users (e.g.\ ``open'', ``close'', ``read'' and ``write'').  This small command set means that the protocol is {\em lightweight\/}, adding very little overhead to the transfer of data.  This may be contrasted with the bloating effect of XML encoding.  A single Styx server can handle many tasks (e.g.\ control, asynchronous messaging and data transfer), removing the need to set up and maintain multiple servers to manage a distributed system.

The Styx Grid Services system defines a Styx server that represents one or more programs, i.e.\ command-line binary executables.  Clients interact with these remote executables by reading from and writing to the files on this Styx server across the Internet.  This is therefore very different from the Web Services model, in which communication is achieved through the exchange of XML documents.  The details of the SGS system are completely hidden from the user: neither service providers nor end-users need to know any of the technical information that follows in the next few sections.

\subsection{The SGS namespace}
In a Styx system, all resources are represented as a set of files that are organized in a hierarchical manner known as a {\em namespace\/}.  A namespace can be thought of as a filesystem of virtual files.  The namespace exposed by a typical Styx Grid Service server is shown in Fig.~\ref{fig:sgsnamespace}.  Briefly, clients typically perform the following steps to run a Styx Grid Service:
\begin{enumerate}
	\item Connect to the server.
	\item Download the configuration of the SGS in question from the {\tt config} file.  This information can be used to help the client to automatically generate a GUI for the SGS or parse a set of command-line arguments.
	\item Create a new instance of the service in question by reading from the {\tt clone} file: the result of this read gives the full URL of the new service instance.
	\item Set the parameters of the service by writing to the files in the {\tt params/} directory.
	\item Upload the input data to the files in the {\tt inputs/} directory.
	\item Start the service running by writing the string ``{\tt start}'' into the {\tt ctl} file.
	\item Monitor the progress and status of the service by reading from the files in the {\tt serviceData/} directory while the service is running.
	\item Get output data from the service (from output files and the standard streams) by reading from the files in the {\tt outputs/} directory while the service is running.
	\item When the service has finished, the instance can be destroyed by writing ``{\tt destroy}'' into the {\tt ctl} file.
\end{enumerate}

Every file and directory on a Styx server can be represented very naturally as a URL.  For example, the file that represents the standard output stream of instance 1 of the the {\tt mySGS} service can be represented by the URL {\tt styx://<server>:<port>/mySGS/instances/1/outputs/stdout}.  This is very important in the context of workflows: these URLs are {\em references to resources\/} and may be passed between services in a workflow to enable direct transfer of data between services (see Sect.~\ref{sec:datastreaming}).

\begin{figure}
\begin{verbatim}
/
|-- mySGS/
|   |-- clone
|   |-- config
|   |-- docs/
|   |   |-- description
|   |   `-- readme.txt
|   `-- instances/
|       |-- 0/
|       |    |-- ctl
|       |    |-- args
|       |    |-- params/
|       |    |   |-- param1
|       |    |   `-- param2
|       |    |-- inputs/
|       |    |   |-- stdin
|       |    |   `-- myinputfile
|       |    |-- outputs/
|       |    |   |-- stdout
|       |    |   |-- stderr
|       |    |   `-- myoutputfile
|       |    |-- serviceData/
|       |    |   |-- status
|       |    |   |-- exitCode
|       |    |   `-- customSDE
|       |    |-- steering/
|       |    |   `-- steerable1
|       |    `-- time/
|       |        |-- currentTime
|       |        |-- creationTime
|       |        `-- terminationTime
|       `-- 1/
`-- mySGS2/
\end{verbatim}
\caption{The namespace (virtual filesystem) of a typical Styx Grid Service server.}\label{fig:sgsnamespace}
\end{figure}
%
\section{Wrapping programs as SGSs}
It is critically important that the process of creating Styx Grid Services from existing programs be as straightforward as possible.  It is intended that the process is sufficiently simple to allow scientists to expose their programs as services without intervention from dedicated technical staff.  The service provider does not need to know any of the details of the Styx protocol or the SGS namespace.

In order to create a Styx Grid Service from a command-line executable, the service provider must provide a description of the executable (the {\em configuration file\/}).  This description is an XML document that conforms to a Document Type Definition (DTD), and thus can be automatically validated.  In the current version of the system, this configuration file must be created by hand but we anticipate creating automated tools to simplify this task.  There is a complete description of the configuration file format, plus many worked examples, on the project website ({\tt http://jstyx.sf.net}).  The configuration file is passed to a general-purpose program that parses the file and creates the SGS server.

A sample configuration file is given in Fig.~\ref{fig:configfile}.  The hierarchical structure of the configuration file closely resembles the namespace of the resulting Styx Grid Service (Fig.~\ref{fig:sgsnamespace}).  The file specifies:
\begin{itemize}
	\item The details of the server itself: the port it will listen on and details of the SSL authentication and encryption (if used).
	\item The name of the Styx Grid Service, the path to the program it is wrapping and a short description.
	\item The command-line parameters that the program expects.
	\item The input files that the program expects (including the standard input stream).
	\item The output files that the program produces (including the standard output and standard error streams).
	\item Any user-specified pieces of service data (i.e. state data about the service such as progress).
	\item Any steerable parameters (see Sect.~\ref{sec:interactivity}).
	\item Any documentation files associated with the program, to provide help to users.
\end{itemize}
Several Styx Grid Services can be specified in one configuration file.  All these SGSs will be exposed under the same server program (which is a {\em container\/} for any number of SGSs).  The section of the configuration file that pertains to a particular SGS is made available for clients to read through the {\tt config} file in the namespace of that SGS.  This {\tt config} file performs an analogous role to that of a Web Services Definition Language (WSDL,~\cite{WSDL}) document, in that it provides a machine-readable specification of the service that can be used to automatically generate client programs.

\begin{figure}
\caption{A sample configuration file for a Styx Grid Services server.}\label{fig:configfile}
\end{figure}
%
\section{Creating workflows with Styx Grid Services}
The above sections (WHICH SHOULD BE MUCH SHORTER!) described why we have chosen to create a new service type and some of the technical details of how the SGS model works.  This model gives several advantages...

\subsection{Passing data directly between service instances}\label{sec:datastreaming}
One common issue in scientific workflows is how data should be passed from service to service.  Let us consider the case of Web Service-based workflows for the moment.  If data volumes are very small the data can be passed between services as part of the SOAP messages.  It does not matter that the data have been encoded into XML, or that the data are passing through the workflow enactor (i.e.\ the client's machine).  However, with moderate or large data volumes it is not desirable to encode the data in XML, or for the data to pass through the enactor.  In this case it is much more efficient for the data to be passed directly from service to service in their raw form, with the SOAP messages being reserved for marshalling the workflow (Fig.~\ref{fig:datastreaming}).  This feature is often referred to as ``third-party data transfer''.

\begin{figure}
\caption{Illustration of direct data passing.  The black arrows represent control messages (e.g.\ SOAP messages in a Web Services system).  These messages are sent by the enactor to create service instances and marshal the workflow.  The red arrows represent the ideal path for data to follow, i.e.\ direct streaming from service to service.}\label{fig:datastreaming}
\end{figure}

Furthermore, in some cases data can be {\em streamed\/} between services: in other words, the data can be passed from one service to the other {\em as soon as they are produced\/}, without waiting for the producing service to proceed to completion.  This is particularly useful when dealing, for example, with sensor data that are produced in a continuous fashion.  This is analogous to the use of filters and pipes on the command line (e.g.\ {\tt prog1 $|$ prog2}) and, indeed, the SGS system allows workflows to be constructed with precisely this syntax (Sect.~\ref{sec:pipes}).

In the SGS system, the direct passing of data between service instances is achieved very simply.  The workflow enactor (whether it be a graphical or command-line tool) passes {\em references\/} (i.e.\ URLs) to the data sources from one service to the next.  As an illustration of this, consider a simple workflow involving two services, A and B, in which the output of service A is passed as an input to service B:
\begin{enumerate}
	\item The workflow enactor creates a new instance of service A and starts it running.
	\item {\em Without waiting for service A to finish\/}, the enactor creates a new instance of service B.
	\item The enactor passes a reference (URL) to the output of service A to the appropriate input of service B.
	\item The enactor starts service B.  Service B then downloads the output data from service A as it runs.
\end{enumerate}

\subsection{SGSs can be used just like local programs}
The SGS system is a ``close'' wrapper around a non-graphical executable program.  It does not attempt to abstract away the details of the command-line parameters of the program or the input and output files involved: rather, it explicitly describes them.  This is therefore an alternative approach to that taken by some systems, which provide access to a program through a remote procedure call (RPC).  However, it is sometimes very difficult to adequately model a scientific program (which may incorporate a number of command-line parameters and input/output files) as an RPC.

Many scientists perform most of their work in command-line environments.  Many command-line environments provide a very sophisticated, customizable and usable interface to the user.  In order to serve this community, Styx Grid Services can be run using simple shell commands.  The fact that an SGS contains a complete description of the executable it wraps means that we can execute remote Styx Grid Services {\em exactly as we would execute local programs\/}.  The {\tt SGSRun} program (provided with the SGS software) is a command-line client that can be used to execute any Styx Grid Service in exactly the same way as the executable it wraps.

For example, consider a simple command-line program, called {\tt myprog}, that reads an input file, processes it, then writes out an output file.  The command line syntax for running this program is:

\begin{verbatim}
myprog -i <inputfile> -o <outputfile>
\end{verbatim}

The relevant section of the configuration file to create a Styx Grid Service from this program would be:

\begin{verbatim}
<gridservice name='myprog' command='/path/to/myprog'>
  <params>
    <param name='inputfile' paramType='flaggedOption' flag='i'/>
    <param name='outputfile' paramType='flaggedOption' flag='o'/>
  </params>
  <inputs>
    <input type='fileFromParam' name='inputfile'/>
  </inputs>
  <outputs>
    <output type='fileFromParam' name='outputfile'/>
  </outputs>
</gridservice>
\end{verbatim}

This specifies that the program reads one input file that is given by the flag ``-i'' and produces one output file that is given by the flag ``-o''.  Once wrapped as a Styx Grid Service, the program can be invoked from anywhere on the Internet using the command:

\begin{verbatim}
SGSRun <hostname> <port> myprog -i <inputfile> -o <outputfile>
\end{verbatim}

The {\tt SGSRun} program downloads the configuration information from the server and uses it to parse the command line arguments.  It then knows that it must upload the input file to the server before running the service.  It downloads the output data from the server and places it in {\tt <outputfile>}.  The user can create a simple shell script that runs {\tt SGSRun} and that contains the hostname and port of the SGS server.  In this way, the command line to execute the SGS is {\em identical\/} to that used to run the program locally.

\subsection{Create workflows with shell scripts}
Given that remote services can be executed just like local programs, a natural extension is to create workflows by writing simple shell scripts.  Workflows, like shell scripts, are themselves programs that are composed of other programs and high-level components.  Let us consider a simple workflow of two Styx Grid Services.  The first, called {\tt calc\_mean}, reads a set of input files, calculates their mean and outputs the result.  These input files might be the result of a set of individual experiments.  The second SGS, called {\tt make\_pic} takes a single input file and turns it into a picture.

Imagine that the user has a set of input files (called {\tt input1.dat}, {\tt input2.dat} etc.) and wants to calculate their mean, then produce a picture of the result.  The shell script that he or she would use would be:

\begin{verbatim}
calc_mean -i input*.dat -o means.dat
make_pic -i means.dat -o means.gif
\end{verbatim}

Note that this is {\em exactly the same script\/} as would be used to invoke the programs if they were installed locally.  (This assumes that the user has created shell scripts called {\tt calc\_mean} and {\tt make\_gif} that invoke the {\tt SGSRun} program as described above.)

This ``workflow'' (shell script) is very simple but not optimally efficient.  The intermediate file {\tt means.dat} is not required by the user: it is simply uploaded to the {\tt make\_pic} service as soon as it is downloaded.  This wastes time and bandwidth.  As discussed in Sect.~\ref{sec:datastreaming}, this intermediate file can be passed directly between the services.  This is achieved with only a minor change to the script:

\begin{verbatim}
calc_mean -i input*.dat -o means.dat.sgsref
make_pic -i means.dat.sgsref -o means.gif
\end{verbatim}

The {\tt .sgsref} extension is a signal to the system to download a {\em reference\/} (URL) to the output file.  This reference is then passed to the {\tt make\_pic} service, which downloads the real {\tt means.dat} file directly from the {\tt calc\_mean} service.

Figure to illustrate this?

\subsubsection{Using the pipe operator.}\label{sec:pipes}
Continuing with the above example, let us imagine that the {\tt calc\_mean} program outputs data on its standard output, instead of to an output file.  Similarly, imagine that the {\tt make\_pic} program reads data on its standard input and outputs the picture on its standard output.  The script to execute this simple workflow (with both local programs {\em and\/} Styx Grid Services) is:

\begin{verbatim}
calc_mean -i input*.dat | make_pic > means.gif
\end{verbatim}

Here, the intermediate data is being streamed to the local client, then streamed back out to the {\tt make\_pic} service.  Again, we can make sure that the intermediate data is streamed directly between the services with a minor change to the script:

\begin{verbatim}
calc_mean -i input*.dat --sgs-output-stdout-ref ...
       ... | make_pic > means.gif
\end{verbatim}

The flag {\tt --sgs-output-stdout-ref} is a signal to print a reference (URL) to the standard output of the {\tt calc\_mean} service to the local machine's standard output, instead of the actual data.  It is this reference that is passed to the standard input of the {\tt make\_pic} service.  In this way the intermediate data are streamed directly between the services, across the Internet.
%
\subsection{Using graphical workflow engines}
The command line interface to the SGS system that is described above is perhaps the simplest way of using Styx Grid Services from the client side.  In many cases, however, there are significant advantages in using more sophisticated graphical tools to interact with services and create workflows.  In particular, graphical interfaces can provide richer interactivity with the SGS server, e.g.: progress and status can be monitored graphically, input parameters can be set using graphical controls and the service can be steered.

The Taverna workbench ({\tt http://taverna.sf.net}) is a graphical workflow system that was designed for performing {\it in silico} experiments in the field of bioinformatics, although it can also be used by other communities.  Using Taverna, the user can build workflows from diverse service types, including Styx Grid Services, Web Services and XXX.

The Triana workflow system ({\tt http://trianacode.org}) is another graphical workflow environment that can interface with many different service types.  Although direct support for Styx Grid Services is not built in at the time of writing, a previous paper~\cite{blower:2005} showed that Styx Grid Services can be wrapped as Web Services, then Triana can be used to run workflows in which data are streamed directly from service to service.
%
\section{Asynchronous notification in the SGS system}
We have discussed (Sect.~\ref{sec:wsproblems}) the problems faced when implementing asynchronous notification systems in Web Services environments: the notification replies to the clients are often blocked by firewalls or NAT.  
%
\section{Security}
%

\section{Web Service Integration}
\label{sec:webservices}

A compelling argument for employing Web services is that through the use of open standards of service description and message exchange such as WSDL and SOAP, diverse underlying resources and codes can interact. While SOAP, WSDL and the plethora of WS-* specifications are useful for describing service entry points and constraints such as security and policy, they are not necessarily ideal for data intensive, or long-running interactions as are often required in Grid computing. In situations such as these, it can be useful to view these Web service standards as comprising a service level which sits above and specifies an underlying execution layer. This execution layer may use different mechanisms for transferring data such GridFTP or, in the case of SGSs, the Styx protocol. The following two sub-sections describe applications of the SGS framework that make use of Web service standards while still maintaining the integral strengths of the Styx protocol within the context of workflow.

\subsection{Wrapping SGSs as Web Services}
AHM 2004 paper~\cite{blower:2004} ...

Another approach to wrapping SGSs as Web services has been implemented by WSPeer~\cite{wspeer}. WSPeer is a Peer-to-Peer oriented API for hosting and invoking Web services which has a binding to the jstyx libraries allowing SOAP messaging to take place using the Styx protocol. In this scenario WSPeer launches as `SOAP capable' Styx service, that is, the service is conceptually an XML document. The SGS namespace is not externally accessible. Instead the client has access to a WSDL file which defines service operations that encapsulate the messages and data to be written to the namespace files. So for example, to write to the \texttt{stdout} file of an SGS, the client invokes the \texttt{setStdout(String uri)} operation defined in the WSDL. The service endpoint contained in the WSDL is the URI of a file to which these messages can be written. The client invocation triggers WSPeer to write the XML to the service file. The service file processes the SOAP message and reads/writes from its parameter files, setting its own file content accordingly. If WSPeer is expecting a response from the service file it has just written to, it subsequently performs a read operation on the file.

\subsection{Wrapping SGSs as WS-Resources}
\label{subsec:ws-resources}

The Web Services Resource Framework (WS-RF) is a recent specification which addresses the need to handle resources that maintain state across service invocations. These resources, called WS-Resources, can be anything from a database entry, to a subscription, to a job running on a Grid. SGSs fit naturally into this class of network entity because they maintain state which can be retrieved and modified. We have explored wrapping SGSs as WS-Resources using WSPeer which supports WS-RF~\cite{wsrf}.

\sloppypar A WS-Resource is defined as a series of \emph{ResourceProperties}, essentially QName/value pairs of a specified data type. These properties are exposed in the WSDL of a service (a WS-RF service) capable of handling certain WS-Resources. ResourceProperties are common to types of resources and therefore a WS-RF service can manage any number of instances of a type of resource. The reference to an instance of a resource which the service acts upon is sent by the client in the header part of the SOAP message. A WS-RF service may also define operations that act on WS-Resources.

The process of exposing an SGS as a WS-Resource involves parsing the \texttt{config} file in the SGS namespace and transforming the configuration data into ResourceProperties. This is not difficult because the configuration file is machine processable. Furthermore SGS defines certain properties which map directly onto WS-RF related specifications. An example of this is the \texttt{time} directory in the SGS namespace which houses files containing data pertinent to the lifetime of the service. These are reflected in properties defined in the WS-ResourceLifetime~\cite{wsrf-lifetime} specification.

There are two types of WS-RF service that can expose a WS-Resource wrapped SGS using WSPeer:

\begin{enumerate}
\item A SOAP capable WS-RF Styx service using the styx protocol to send and receive XML.
\item A broker WS-RF service. In this case the service uses HTTP.
\end{enumerate}

An important specification related to WS-RF is WS-Notification~\cite{wsrf-notification}. WS-Notification allows clients to be notified of events fired by topics that they have previously subscribed to. In terms of SGS, a number of files are suitable candidates for being exposed as topics in the WSDL of the WS-RF service, particularly the \texttt{serviceData} files. When the WS-Peer generated WS-RF service is using the Styx protocol, these notifications can take the form of pseudo-notifications as described in Section [IS IT DESCRIBED?] allowing clients behind firewalls and Network Address Translation systems to receive notifications. When the server is running over HTTP, the standard notification exchange occurs.

The \texttt{stdout} file of an SGS is important in terms of workflow because it allows data to flow directly between applications rather than via a workflow editor or controller. In terms of wrapping an SGS as a WS-Resource, it is worth noting that this file is not a good candidate for being exposed as a topic  because the notification messages defined by WS-Notification are verbose and designed for discreet events. Attempting to stream voluminous amounts of data using this mechanism would be disastrous. Instead the wrapping should understood in terms of a service and execution level. The URI that the \texttt{stdout} file contains can be set using standard WS-RF message exchanges. The actual data transfer however, should remain in the styx domain which is less self-decribing but more efficient.



\section{Interactivity} \label{sec:interactivity}
Something on computational steering...

\section{Conclusions}


\section*{Acknowledgements}
Tom Oinn, Inferno guys, Trustin Lee ...
%
% ---- Bibliography ----
%
\bibliographystyle{splncs}
\bibliography{refs}

\end{document}
