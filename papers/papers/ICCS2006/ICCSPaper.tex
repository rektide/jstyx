% Lecture Notes in Computer Science Latex2e Style file,
% ftp://ftp.springer.de/pub/tex/latex/llncs/latex2e/llncs2e.zip
%
% $Revision$
% $Date$
% $Log$
% Revision 1.3  2005/12/13 17:59:24  jonblower
% Added introductory material and the SGS namespace
%
% Revision 1.2  2005/12/13 15:28:22  jonblower
% Initial import
%

\documentclass{llncs}
%
\begin{document}
%
\title{Styx Grid Services: Lightweight, easy-to-use middleware for e-Science workflows}
%
\titlerunning{Styx Grid Services}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Jon Blower\inst{1} \and Andrew Harrison\inst{2}
\and Keith Haines\inst{1} \and Ed Llewellin\inst{3}}
%
\authorrunning{J. Blower et al.}   % abbreviated author list (for running head)
%
%%%% modified list of authors for the TOC (add the affiliations)
\tocauthor{Jon Blower (University of Reading),
Andrew Harrison (University of Cardiff),
Keith Haines (University of Reading),
Ed Llewellin (University of Cambridge)}
%
\institute{Reading e-Science Centre, Environmental Systems Science Centre,
University of Reading, Reading RG6 6AL, UK\\
\email{jdb@mail.nerc-essc.ac.uk},\\
\and
University of Cardiff, Cardiff, UK
\and
University of Cambridge, Cambridge UK}

\maketitle              % typeset the title of the contribution

\begin{abstract}
(70-150 words)
\end{abstract}
%
\section{Introduction}
There is much current interest in the use of Service-Oriented Architectures (SOAs) in scientific computing.  A key tenet of the SOA paradigm is that one can expose resources such as data stores, computing resources, sensors and computer programs as {\em services\/} that are available for access through the Internet.  Each service is independent from all other services and, indeed, the services can be managed by any number of {\em service providers\/}.  The end user (e.g.\ the scientist) can perform complex, distributed tasks by composing these services into {\em workflows\/}.  In this paper we shall focus on the issue of exposing existing computer programs as services and creating workflows from these services.  However, many of the methods we discuss could be applied to other types of resource.

In many scientific fields, the community in question has produced useful pieces of code that have been tried and tested over a substantial period of time (these programs are often termed ``legacy'' codes).  It is usually not practical for the code to be re-written and so a common task, addressed by many e-Science projects (e.g.\ REFs) is to create software that ``wraps'' an existing piece of code as some kind of Internet service, for example a Web Service (e.g.\ Soaplab, REF), OGSI Grid Service (e.g.\ GEMLCA, REF) or WS-Resource (e.g.\ WEDS, REF).  These systems are not just useful for legacy codes: newly-written code can also be be exposed as a service.  In this way, the writing of the code is divorced from the procedure of creating the service.  There are many reasons for wishing to expose a program as a service:
\begin{itemize}
	\item The code must run on a powerful resource (e.g.\ a compute cluster) but users want to access the code from a more modest machine, such as a laptop.
	\item The code is tied to a particular platform (e.g. 64-bit Solaris) but users want to access the code from other platforms.
	\item The code has many dependencies (on particular versions of libraries for example) and the exposure of the code as a service removed the need for users to install all these dependencies.
	\item The code depends on data from a large data archive and so should run on a machine that is close to the archive.  However, users want to run the code from anywhere on the Internet.
	\item The code is useful to a wide community and the provision of the code as a service removes the need for multiple users to install it locally.
\end{itemize}

Despite these benefits, in many scientific fields there are still few examples of genuinely useful, widely-available Internet services that scientists can access.  (In this paper we use the term ``Internet services'' as an umbrella term to cover Web Services, Grid Services, WS-Resources and other services that are accessible over the Internet.)  As noted in (WEDS and MOAN), this is partly due to the technical difficulty in creating many types of service, which is why the aforementioned wrapper systems have been developed.  A ``critical mass'' of useful services is required to exist before other potential service providers perceive that it is worth their time and effort to add services of their own.

\subsection{Problems with Web Services-based distributed systems}
Although the above wrapper systems undoubtedly make the job of creating services much easier than would otherwise be the case, we believe that further progress can be made towards increasing the ease of both creating and using Internet services.  One key issue, we believe, is the nature of the services themselves.  Most e-Science projects employ Web Services (or some variant) as the core service type.  While this certainly brings many benefits, it also brings problems in some cases.  A common problem is that of data transfer: Web Services produce and consume XML documents, but it is undesirable to encode anything but a trivial amount of data in XML due to the time and resource required to perform this encoding and the resulting increase in the data volumes (REF).  When creating Web Services that deal with moderate or large data volumes, it is common to use a different transport mechanism for the data inputs and outputs, using the exchange of XML documents simply as a control mechanism (e.g.\ REF).  The need to use two different server systems (the Web Services server and the data server) increases the complexity of the system.

Another common issue arises when creating services that represent long-running programs.  In these cases it is desirable to incorporate a mechanism for notifying clients of the progress of the program and when it has completed.  The Web Services Resource Framework (WS-RF, REF) specifies a method for achieving this (WS-Notification, REF), but it, like other preceding notification mechanisms (e.g. OGSI) suffer from a serious problem.  In order to receive notifications of progress, status etc., the client usually has to run a server process that listens for incoming progress messages (``callbacks'').  However, if the client is behind a firewall that blocks incoming connections on the port(s) in question, these messages will never be received and, what is worse, the client may never know why.  Similar problems are faced with clients that are behind Network Address Translation (NAT) routers.  In many situations the user has no control over the firewall or NAT settings and so these notification mechanisms are often defeated.

In this paper we shall describe a new type of Internet service called the {\em Styx Grid Service\/} or SGS.  The SGS architecture addresses the above problems, as well as providing other benefits.  A key feature is that it is very easy to create Styx Grid Services that wrap existing programs: we believe that it is significantly easier than using any of the above wrapper systems.  It is also very easy to use Styx Grid Services: the architecture is designed so that any SGS can be run from the command line {\em exactly as if it were a local program\/}.  Workflows can therefore be created using simple shell scripts (or batch files in Windows).  Alternatively, the SGS API allows the creation of custom client programs and integration with many different workflow systems.  We shall demonstrate how Styx Grid Services can interoperate with other types of Internet services such as Web Services and WS-Resources.

%
\section{The Styx Grid Services system}
\subsection{Background}
The key aims of the Styx Grid Services system are to make the use of remotely-deployed programs as easy as using local programs and to allow them to be composed into efficient workflows.  The design of the system is heavily influenced by the Inferno (REF) and Plan~9 (REF) operating systems, in which local and remote resources are treated {\em identically\/}.  This is achieved because of the following two facts: (1) All resources are virtualized as a file or set of files (just as Unix variants often represent the mouse as the file {\tt /dev/mouse}); (2) all communication is performed using a file-sharing protocol.  Applications do not know whether they are operating on local or remote files: the routing of messages is handled by the underlying operating system.

The file-sharing protocol used in Inferno is called {\em Styx\/}; Plan~9 uses an identical protocol called {\em 9P\/} (the latest version of Styx is also known as 9P2000).  Styx has a long history and was invented by the original developers of Unix (REF).  It has several major advantages.  Styx only needs to operate on files and so it has a very small command set (13 commands) with well-defined semantics, many of which will be familiar to most users (e.g.\ ``open'', ``close'', ``read'' and ``write'').  This small command set means that the protocol is {\em lightweight\/} adding very little overhead to the transfer of data, which may be contrasted with the bloating effect of XML encoding.  A single Styx server can handle many tasks (e.g.\ control, asynchronous messaging and data transfer), removing the need to set up and maintain several servers to manage a distributed system.

The Styx Grid Services system defines a Styx server that represents a program, i.e.\ a binary executable.  Clients (i.e.\ users) interact with the remote executable by reading from and writing to special files on this Styx server across the Internet.  This is therefore very different from the Web Services model, in which communication is achieved through the exchange of XML documents.  The details of the SGS system are completely hidden from the user: neither service providers nor end-users need to know any of the technical details that follow in the next few paragraphs.

\subsection{The SGS namespace}
In a Styx system, all resources are represented as a set of files that are organized in a hierarchical manner known as a {\em namespace\/}.  A namespace can be thought of as a filesystem of virtual files.  The namespace exposed by a typical Styx Grid Service server is shown in Fig.~\ref{fig:sgsnamespace}.  Briefly, clients perform the following steps to run a Styx Grid Service:
\begin{enumerate}
	\item Connect to the server.
	\item Download the configuration of the SGS in question from the {\tt config} file.  This information can be used to help the client to automatically generate a GUI for the SGS or parse a set of command-line arguments.
	\item Create a new instance of the service in question by reading from the {\tt clone} file: the result of this read gives the full URL of the new service instance.
	\item Set the parameters of the service by writing to the files in the {\tt params/} directory.
	\item Upload the input data to the files in the {\tt inputs/} directory.
	\item Start the service running by writing the string ``{\tt start}'' into the {\tt ctl} file.
	\item Monitor the progress and status of the service by reading from the files in the {\tt serviceData/} directory while the service is running.
	\item Get output data from the service (from output files and the standard streams) by reading from the files in the {\tt outputs/} directory while the service is running.
	\item When the service has finished, the instance can be destroyed by writing ``{\tt destroy}'' into the {\tt ctl} file.
\end{enumerate}

\begin{figure}
{\tt /  {\em The root directory of the server}\\
|-- mySGS/\\
|   |-- clone\\
|   |-- config\\
|   |-- docs/\\
|   |   |-- description\\
|   |   `-- readme.txt\\
|   `-- instances/\\
|       |-- 0/\\
|       |    |-- ctl\\
|       |    |-- args\\
|       |    |-- params/\\
|       |    |   |-- param1\\
|       |    |   `-- param2\\
|       |    |-- inputs/\\
|       |    |   |-- stdin\\
|       |    |   `-- myinputfile\\
|       |    |-- outputs/\\
|       |    |   |-- stdout\\
|       |    |   |-- stderr\\
|       |    |   `-- myoutputfile\\
|       |    |-- serviceData/\\
|       |    |   |-- status\\
|       |    |   |-- exitCode\\
|       |    |   `-- customSDE\\
|       |    |-- steering/\\
|       |    |   `-- steerable1\\
|       |    `-- time/\\
|       |        |-- currentTime\\
|       |        |-- creationTime\\
|       |        `-- terminationTime\\
|       `-- 1/\\
`-- mySGS2/}
\caption{The namespace of a typical Styx Grid Service server.}\label{fig:sgsnamespace}
\end{figure}

\subsection{Resource lifecycle}
%
\section{Wrapping programs as SGSs}
%
\section{SGS Clients 1: The command line}
\subsection{Create workflows with shell scripts}
%
\section{SGS Clients 2: Graphical workflow engines}
%
\section{Security}
%
\section{Compatibility with other service types}
\subsection{Wrapping SGSs as WS-Resources}
%
\section{Interactivity}
Something on computational steering...
%
% ---- Bibliography ----
%
\begin{thebibliography}{refs}
%\bibliography{refs}
%
\bibitem[1980]{2clar:eke}
Clarke, F., Ekeland, I.:
Nonlinear oscillations and
boundary-value problems for Hamiltonian systems.
Arch. Rat. Mech. Anal. {\bf 78} (1982) 315--333

\end{thebibliography}
\end{document}
