\documentclass[a4paper]{article}
\usepackage{graphicx}
%\usepackage{amsmath}
\usepackage[authoryear]{natbib}
%\usepackage{subfig}
% remember to use -sPAPERSIZE=a4 as option to ps2pdf to stop these margins getting corrupted
\usepackage[left=3cm, right=3cm, top=3cm, bottom=3cm, nohead, nofoot]{geometry}
\usepackage{multicol}
\usepackage{nopageno} % removes page numbers
%\usepackage[pdftex]{hyperref} % inserts hyperlinks correctly for PDFs

% Make captions italic
\usepackage[it]{caption}
\renewcommand\captionfont{\itshape}

\usepackage{bar} % bar charts

\bibpunct{[}{]}{,}{n}{,}{,} % citations in format [1], [2,3] etc

% Voodoo for single-column figures and tables - note that they won't float!
\makeatletter
\newenvironment{tablehere}
  {\def\@captype{table}}
  {}
\newenvironment{figurehere}
  {\def\@captype{figure}}
  {}
\makeatother

% Command to put some centred text in a box
\newcommand{\boxit}[1]{
\begin{center}
\noindent \fbox{\parbox{2.7in}{\centerline{#1}}}
\end{center}
}
% Command for scientific notation
\newcommand{\scinot}[2]{ #1\times10^{#2} }

\begin{document}

\title{VEIGA: a Very Easy Interface to Grid Applications}

\author{\textbf{Jon Blower$^{*}$}, Keith Haines}
\date{}

\maketitle

\begin{center}
Reading e-Science Centre, Environmental Systems Science Centre, University of Reading, Harry Pitt Building, University of Reading, Whiteknights, Reading RG6 6AL \\
\medskip
$^{*}$ Corresponding author: email address jdb@mail.nerc-essc.ac.uk
\end{center}

\bigskip

\begin{abstract}
We present VEIGA, a Very Easy Interface to Grid Applications.  The aim of VEIGA is to make the running of applications on a Grid as easy as running applications on one's own computer.  Applications that are deployed on a VEIGA server can be run from remote locations exactly as if they were local programs.  Workflows can be created with very simple shell scripts and data can be streamed directly between service instances across the Internet.  VEIGA can be employed as an easy-to-use front-end to Condor pools, Globus resources and other distributed systems.  In order to run jobs on a VEIGA system, the user needs only to install the lightweight VEIGA client software, which consists of a small set of self-contained, pure Java libraries totalling less than 3 MB in size.  The VEIGA server software is similarly lightweight and requires minimal setup.
\end{abstract}

\bigskip

\begin{multicols}{2}

\section{Introduction}
As Grid technology matures, an increasing amount of attention is being devoted to the problem of enhancing the usability of Grid systems.  Grids are often (necessarily) complex, but most of this complexity should not be exposed to the user.  It is a well-known problem [REFs] that many Grid toolkits (e.g.\ Globus, REF) are difficult for novice users to install and use.  This is often because such toolkits are aimed at application developers rather than end users and a further level of abstraction is required to give the desired level of usability.  This has led to the development of systems such as GEMLCA, WEDS and GridSAM [REFs], which aim to hide the details of the Grid middleware behind a Web or Web Services interface.

In order to run a simple job on a typical Grid system, the user must perform the following steps:

\begin{enumerate}
\item Upload (``stage-in'') the required input files to a location that is accessible by the system that will execute the job.
\item Send a command to execute the job, passing in any necessary command-line arguments, plus links to the input files.
\item Wait for the job to finish: this might involve the user sending repeated requests for updates or the user might be notified by some mechanism such as email.
\item Download (``stage-out'') the output files that have been produced.
\end{enumerate}

There are often hidden complexities in even this simple procedure.  For example, the user must make sure to upload the input files to an appropriate location and it might not be obvious to the user what this location is:  the server on which the job ultimately runs might not be the server that hosts the input files (for good reasons).  The user would then need to know how to construct a link (e.g.\ a URL) to the input file and this link must be passed to the server that runs the job.

All these operations must usually be done securely, which means that the user has to authenticate on every system that he or she accesses.  The Globus Security Infrastructure (GSI), in common with other public-key infrastructure (PKI) schemes, provides a ``single sign-on'' to Grid resources, alleviating this problem somewhat.

The problem of workflow is a large topic of current research and many tools [REFs] have emerged that aim to provide the user with the means to combine many different distributed applications to achieve a goal.  However, these tools are often large and complex and there are few systems that allow simple workflows to be created in a simple manner.

\subsection{How VEIGA helps}
The aim of VEIGA is to allow users to run jobs on Grid resources with a single command that is {\em identical\/} to the command that would be used to run the job as a program on the user's local machine.  Input and output files are staged in and out automatically and the standard streams are redirected.  Workflows can be created using simple shell scripts and data can be streamed directly between jobs in the workflow.  ``Composite'' jobs (which involve running the same program many times over different inputs) can similarly be run using a single, intuitive command.

The VEIGA software is very lightweight: the whole distribution is less than 3 MB in size, self-contained (i.e.\ it does not rely on external dependencies) and is easy to install and configure.  Simple, ad-hoc Grids can be created very easily with VEIGA alone, although these will not have all the features offered by larger middleware distributions.  VEIGA can interface with other Grid systems, providing a familiar and uniform interface to diverse back-ends.

By providing an intuitive yet powerful interface to Grid systems, we hope that the power of Grid technology will become available to many more users, particularly those who have yet to be engaged by e-Science programmes.


\section{VEIGA overview}
Figure~\ref{fig:veigaarchitecture} shows a high-level view of a VEIGA client-server system.  Once an application is deployed on the VEIGA server, clients can run that application from anywhere on the Internet by entering a single command, exactly as if the application were deployed on the client's machine.  The application itself can either run directly on the VEIGA server itself or on another host: the VEIGA server has the ability to submit the application to a Condor pool or Globus resource.  The user needs to know nothing of where the application ultimately runs.

\begin{figure*}
\centering
%\includegraphics[width=0.8\textwidth]{sgsnamespace.png}
\caption{VEIGA architecture.  The VEIGA server holds a set of deployed applications, together with a configuration file that describes each application in terms of its command-line arguments and input/output files.  These applications can be run either on the VEIGA server itself or the VEIGA system can run the applications on another machine using Condor or Globus.  In all cases, the client uses the same command to run the application: this command is identical to that which would be used to run the application if it were installed locally on the client's machine.}
\label{fig:veigaarchitecture}
\end{figure*}

\subsection{Background}
VEIGA was formerly known as the ``Styx Grid Services'' (SGS) project.  This was so called because the core of the system is the Styx protocol for distributed systems [REF].  In previous papers [REFs] and the project website [REF] we have described many of the technical details behind the implementation of the system.  The inner workings of the system will therefore not be discussed at length in this paper.

The Styx protocol is suitable as a basis for VEIGA for many reasons.  The main reason is that a single Styx connection can handle many tasks simultaneously (it is a multiplexing protocol).  File transfers, progress notifications and control commands can all be marshalled on the same, persistent connection between the client (i.e.\ the user) and the server.  A VEIGA server therefore only requires a single incoming port to be open through its firewall and VEIGA clients require {\em no\/} incoming ports to be open.  This considerably simplifies the implementation and deployment of servers and clients and contributes to the lightweight and intuitive nature of the VEIGA system.


\section{A basic VEIGA system}\label{sec:basicveiga}
The best way to illustrate the main features of VEIGA is to work through an example.  In this section we shall describe the process of setting up a new VEIGA server, deploying an application and running it from a remote location.  We shall take as an example an application called {\tt lbflow} [REF], which performs a Lattice Boltzmann (LB) simulation of fluid flow through a porous medium.

The {\tt lbflow} application reads a single input file containing configuration information and writes a single output file containing results (the velocity and pressure of the fluid at each node in the simulation).  The procedure for deploying {\tt lbflow} on a VEIGA server is very simple.  After installing the VEIGA server software the {\tt lbflow} application is copied to the VEIGA server and an entry is made in the server's configuration file, describing the application (figure~\ref{fig:lbflowconfig}).

\begin{figure*}
\centering
\begin{verbatim}
<gridservice name="lbflow" command="/path/to/lbflow"
     description="Lattice Boltzman simulation">
  <params>
     <param name="inputfile" paramType="flaggedOption" flag="i" required="yes"/>
     <param name="outputfile" paramType="flaggedOption" flag="o" required="yes"/>
   </params>
   <inputs>
     <input type="fileFromParam" name="inputfile"/>
   </inputs>
   <outputs>
     <output type="fileFromParam" name="outputfile"/>
     <output type="stream" name="stdout"/>
   </outputs>
</gridservice>
\end{verbatim}
\caption{Portion of the configuration file on a VEIGA server, describing the {\tt lbflow} application that is deployed.  This specifies that the application expects one input file, whose name is given by the command-line argument following the ``-i'' flag.  The application outputs one file, whose name is given by the command-line argument following the ``-o'' flag, and also outputs data on its standard output stream.}
\label{fig:lbflowconfig}
\end{figure*}

Having constructed the configuration file and started the server, clients can run the {\tt lbflow} program from remote locations.  They do so through the {\tt veigarun} program, which is a generic client program for running {\em any\/} VEIGA application.  Its syntax is:

\begin{verbatim}
veigarun <host> <port> <appname> [args]
\end{verbatim}
where {\tt <host>} and {\tt <port>\/} are the host name (or IP address) and port of the VEIGA server, {\tt <appname>} is the name of the application that is deployed on the VEIGA server and {\tt [args]} is the list of command-line arguments, exactly as they would appear if the program were being run locally.

Therefore, to run the {\tt lbflow} that is hosted on the VEIGA server at {\tt veigahost.com}, port 9092, the user enters:

\begin{verbatim}
veigarun veigahost.com 9092 \
  lbflow -i input.dat -o results.dat
\end{verbatim}

The {\tt veigarun} program performs the following tasks:

\begin{enumerate}
\item Downloads the configuration information for the {\tt lbflow} application from the server.
\item Uses the information in the configuration file to parse the command-line arguments.
\item It then knows that {\tt input.dat} is an input file and so uploads it to the server.
\item Instructs the server to start the {\tt lbflow} application.
\item Downloads the output data {\em as they are produced\/}. Each time the {\tt lbflow} application writes new data to its output file the new data are sent to the client, where they end up in {\tt results.dat}.  Similarly, the data from the standard output of the application appear on the client's console window.
\item Waits for the remote application to finish and captures its exit code.  The {\tt veigarun} program then exits with the exit code of the remote application.
\end{enumerate}

It is a very easy task for the client to create a shell script (or batch file in Windows) called {\tt lbflow}, which runs the {\tt veigarun} program and contains the server details.  Then, the client's {\tt lbflow} script can be treated {\em exactly\/} as if it were the {\tt lbflow} program itself.

Further examples can be explored in the project tutorial (REF).  Any command-line application can be deployed in this manner.

\subsection{Interactive use and data streaming}\label{sec:interactive}
One advantage of VEIGA over other Grid systems is the ability to run interactive applications.  These include applications that require the user to enter data via the keyboard and applications that can be computationally steered [REF].  The standard streams (stdin, stdout and stderr) are redirected from and to the client's console window and any output from the server is instantly sent back to the client.

A general principle of VEIGA is that data should be transmitted as soon as they are produced, without waiting for the application to complete.  This applies to both the standard streams and to other input and output files.  This allows data to be streamed from the client to the server and vice-versa and is important for workflows (see REF).

However, interactive use is generally only possible for applications that run on the VEIGA server itself.  If the application is run on a different back-end system such as Condor (see REF), interactive use might not be possible because the complete standard input data are required in advance and the output is not copied back to the VEIGA server until the application has finished on the back-end system.

\subsection{Security}
TODO

\section{Workflows}\label{sec:workflows}
We have seen that applications that are deployed on a VEIGA server can be run exactly as if they were installed on the client's local machine.  The logical extension of this is that multiple applications can be combined into workflows using shell scripts (or batch files under Windows).  This is discussed in more detail in [REF], but the main points are summarized here.

Let us consider a simple workflow of two VEIGA applications.  The first is the {\tt lbflow} application from the above example.  The second, called {\tt plot} produces a graph from an input file.  The shell script (workflow) that would be used to run the Lattice Boltzmann simulation and plot its output as a graph would be:

\begin{verbatim}
lbflow -i in.dat -o out.dat
plot -i out.dat -o graph.gif
\end{verbatim}

Note that this is {\em exactly the same script\/} as would be used to invoke the programs if they were installed locally.  (This assumes that the user has created wrapper scripts called {\tt lbflow} and {\tt plot} that invoke the {\tt veigarun} program as described above.)

The above ``workflow'' (shell script) is very simple but not optimally efficient.  The intermediate file {\tt out.dat} is not required by the user: it is simply uploaded to the {\tt plot} application as soon as it is downloaded.  This wastes time and bandwidth.  The intermediate file can be {\em passed directly between the services\/} with only a minor change to the script:

\begin{verbatim}
lbflow -i input.dat -o out.dat.sgsref
plot -i out.dat.sgsref -o graph.gif
\end{verbatim}

The {\tt .sgsref} extension is a signal to the system to download a {\em reference\/} (URL) to the output file and place it in the file {\tt out.dat.sgsref}.  This reference is then passed to the {\tt plot} service, which downloads the real file directly from the {\tt lbflow} service.  Hence this intermediate file does not pass through the workflow enactor (i.e.\ the client's machine).  See figure~\ref{fig:datapassing}.

\begin{figure*}
\centering
\includegraphics[height=4.2cm]{datapassing.eps}
\caption{NEED TO UPDATE THIS FIGURE. Illustration of direct data passing between VEIGA applications.  The ellipses are applications that are deployed on VEIGA servers and the dotted box represents the client's machine.  The dashed arrows represent data transfers that result from the first script in section~\ref{sec:workflows}.  The intermediate file {\tt out.dat} is not required by the client and so the workflow can be arranged so that this file is passed directly between the VEIGA servers (solid black arrows).}\label{fig:datapassing}
\end{figure*}

Data can also be streamed from one VEIGA application to the next through use of the pipe operator, for example:

\begin{verbatim}
myprog input.dat | plot > graph.gif
\end{verbatim}
See [REF] for more details.

Although very convenient, this method of constructing workflows using shell scripts has some weaknesses. The inputs and outputs of VEIGA applications (just like local applications) are files and so the ``workflow engine'' (i.e.\ the shell environment) performs no type checking on these entities.  The reponsibility of checking for validity of inputs is left to the applications themselves.  Secondly, although constructs such as loops are supported by the shell, the variables used to control these loops cannot be read directly from the outputs of the applications.

\section{Running multiple jobs with Condor}\label{sec:condor}
So far we have examined applications that run on the VEIGA server itself.  The simplicity and ease of use of VEIGA can be combined with the power of Condor to allow users to run applications multiple times over different inputs.  Condor [REF] is a popular and mature system for running applications in this manner.  Large numbers of machines (which are commonly ordinary desktop machines) can be brought together in a ``pool'' and users can execute their applications on this pool.  It is commonly employed in Monte Carlo simulations, parameter sweeps and other tasks that require ``high-throughput computing'' (HTC).  These tasks are extremely common in scientific computing.

A VEIGA server can be set up on a Condor submit host (i.e.\ a machine that is able to submit jobs to a particular Condor pool).  In this case, the applications that are deployed on the VEIGA server can be run on the Condor pool.  A single instance of an application can be run exactly as described above: there is no change from the user's point of view, except that interactive use will not be supported (section~\ref{sec:interactive}).  In this case, Condor is essentially being used for load balancing, ensuring that different instances of the application run on different hosts.

A very important and powerful new feature in VEIGA is the ability to run multiple jobs with a single command.  Let us imagine that the user wishes to run the  {\tt lbflow} application (section~\ref{sec:basicveiga}) over a hundred different input files, each containing a different configuration.  The user would place the input files in a local directory called ``inputs'' and run the following command from his or her local machine:

\begin{verbatim}
lbflow -i inputs -o outputs
\end{verbatim}
(Again, this assumes that the user has created a script called {\tt lbflow} that wraps the {\tt veigarun} program.)  The {\tt inputs} directory and its contents are uploaded to the VEIGA server as before.  VEIGA recognizes that the user has specified a directory of inputs instead of a single file and therefore it knows that it must run the {\tt lbflow} program many times, using a different input file each time.  This is achieved through Condor.

Each instance of the {\tt lbflow} program produces an output file and writes data to its standard output as before.  These output files are automatically downloaded by the VEIGA client software and are placed in the {\tt outputs} and {\tt stdout} directory respectively.  An information file is downloaded that tells the user which input files correspond to which output files, and also details whether each individual job was successful or not.

\section{Using VEIGA to submit jobs to Globus resources}
The Globus Toolkit (GT, [REF]) is a widely-used open-source toolkit for building Grid systems and applications.  It is now in version 4, although most production Grids (including the UK National Grid Service) are based on version 2.  The Globus Toolkit is a mature and feature-rich system but its complexity means that novice users find it difficult to use and the software itself can be difficult to install due, for example, to dependency issues.

Many projects [REFs] have dealt with this issue by hiding the complexity of Globus behind a more user-friendly interface and the same can be achieved with VEIGA.  SAY MORE HERE.

\section{Discussion}
We have presented VEIGA, a Very Easy Interface to Grid Applications. We have shown how applications can be deployed on a VEIGA server and run by users in exactly the manner in which they would run local programs.  The authors hope that the VEIGA system will greatly reduce the barrier to uptake of Grid technology by providing users with familiar interfaces to Grid resources.

The intutive VEIGA interface can be used to submit jobs to Condor pools and Globus resources.  In this respect there is clear overlap between VEIGA and other job submission and monitoring systems such as GridSAM.  There are advantages and disadvantages to both systems.  For example, GridSAM does not currently allow multiple job submission (section~\ref{sec:condor}) due to limitations in the Job Submission Description Language (JSDL) on which it is based.  However, GridSAM is currently more mature and robust than VEIGA and supports the execution of jobs on more back-end systems such as Sun GridEngine.  We are actively seeking collaboration with the GridSAM developers and intend to minimize the duplication of effort between the two systems.

The main areas in which VEIGA requires improvement are robustness and fault tolerance.  Improvements need to be made to ensure that the system responds gracefully to failures at both the server and client.

\section*{Acknowledgements}


\end{multicols}

\bibliographystyle{ametsoc}
\bibliography{refs}

\end{document}


