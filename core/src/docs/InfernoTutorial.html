<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
<head>
<title>Inferno tutorial</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<link rel="stylesheet" type="text/css" href="css/jstyx2.css">
</head>

<body>

<p><em>The latest version of this file can be found at
<a href="http://jstyx.sourceforge.net/docs/InfernoTutorial.html">http://jstyx.sourceforge.net/docs/InfernoTutorial.html</a>
</em></p>

<h1>Inferno tutorial</h1>

<h2>Requirements</h2>
<p>It is perfectly possible to work through this tutorial with a single computer
(Windows NT/2000/XP, Linux, Solaris, MacOSX or FreeBSD).  However, it is more
satisfying to use two networked computers to show yourself just how easy it is
to connect them and exchange data, especially if the computers are running
different operating systems.</p>
<p>As we shall see, many Inferno commands have direct equivalents in Unix, so
familiarity with Unix or Linux is useful but by no means essential. A
three-button mouse is highly desirable for working within Inferno’s graphical
environment.</p>

<h2>Why Inferno?</h2>
<p>With so many other distributed computing technologies out there, why are we
introducing another one, which is probably less well-known than others? 
There are several reasons:</p>
<ul>
<li>Inferno is designed from the ground up for cross-platform distributed computing.</li>
<li>It is a very mature technology, originating around 20 years ago in Lucent’s
Bell Labs.  It has been used in industrial-quality products for many years and
is known to be robust.</li>
<li>It is free and Open Source for non-commercial applications
(see <a href="http://www.vitanuova.com/inferno/licence.html">http://www.vitanuova.com/inferno/licence.html</a>).</li>
<li>It is an operating system, but is typically run as an emulated application
in another host OS.  In this mode it takes up less than 1MB of RAM so it is
extremely lightweight (considering its background in embedded systems, this is
not surprising)</li>
<li>In all these platforms, Inferno provides an identical environment for its
applications (i.e. true platform independence).  There are no exceptions to this.</li>
<li>Unix and Linux users will already be familiar with many of Inferno’s commands.</li>
</ul>

<h2>Installing Inferno</h2>
<p>Installing Inferno is very easy:</p>
<ol>
<li>Download the latest version from Vita Nuova’s website at
<a href="http://www.vitanuova.com/inferno/downloads.html">http://www.vitanuova.com/inferno/downloads.html</a>. 
(At the time of writing, the latest version is the Fourth Edition, 20040905.) 
Unless you have a narrowband Internet connection, the easiest thing to do is to
download the CD image.</li>
<li>You may wish to install Inferno as a dedicated user (on Unix and Linux I
normally create a user and group called inferno to own the installation),
but this is optional.</li>
<li>Instructions for installing are on the download page but, in a nutshell,
you need to: (i) Unzip the CD image;  (ii) burn to a CD;  (iii) insert the CD
and run the relevant installation program in the <code>&lt;cdroot&gt;/install</code> directory.</li>
<li>The installation should proceed with no warnings or errors.  I have heard
reports of some CD burners not correctly burning the CD image, so if you get
error messages, try burning the CD on a different machine (I use x-cdroast
on Red Hat Linux 9 with no problems).</li>
<li>Create a new user (e.g. Jon) by copying the <code>&lt;inferno root&gt;/usr/inferno</code>
directory to <code>&lt;inferno root&gt;/usr/Jon</code> and giving Jon ownership
of this directory and all its contents.  Do this for as many users as you like.</li>
<li>Set the environment variable <code>EMU</code> to the string <code>&quot;-r&lt;inferno root&gt;&quot;</code>.
(e.g. <code>setenv EMU &quot;-r/usr/inferno&quot;</code> in the C shell).</li>
<li>Add the directory containing the correct executables to your PATH. 
For example, on Linux, the executables are in <code>&lt;inferno root&gt;/Linux/386/bin</code>
and in Windows (NT, 2000 and XP) the executables are in <code>&lt;inferno root&gt;/Nt/386/bin</code>.
</li>
</ol>

<h2>Running Inferno</h2>
<p>Inferno is normally run as a non-privileged user (i.e. not root).  When
Inferno interacts with the host OS (e.g. to run a native program), any programs
will then run with the privileges of the user that started Inferno.  Therefore
Inferno should not be able to damage the installation of the host OS.</p>

<p>Test that you can run Inferno by typing <code>emu</code> at a command prompt.
If you get a message like <code>&quot;panic: root path does not exist&quot;</code>
or <code>&quot;'/dis' file does not exist&quot;</code>, you have not set your
<code>EMU</code> environment variable correctly (see item 6 in the section
&quot;Installing Inferno&quot;).  You can also specify the root of the distribution
by running <code>&quot;emu -r&lt;inferno root&gt;&quot;</code>.  This is especially
useful if you have multiple Inferno installations on the same machine.</p>

<p>If all is well, you will get a semicolon as a command-line prompt.  Type
<code>pwd</code> and press enter.  This will give you the current directory in
Inferno (not the host OS), which will probably be Inferno's root directory
(<code>/</code>, a single slash).  Type <code>lc</code> and press enter and you
will see all the files and directories in the current directory.</p>

<p>To quit Inferno on most systems, press <code>Ctrl-C</code>.  On Solaris (on
my system at least) it seems that the backspace key is used to quit.  This can
be rather annoying as you can easily end up quitting Inferno when you meant
to erase a character.  If you work in Inferno in GUI mode (see &quot;GUI
applications&quot; below), this is not a problem.</p>

<h2>Basic Inferno</h2>
<p>You should now be at an Inferno command prompt (the semicolon).  Your username
in Inferno is the same as the username in the host OS that you used to run
Inferno.  To check what the name of the current user is (the equivalent of
<code>whoami</code> in Unix), enter <code>&quot;cat /dev/user&quot;</code> at
the command prompt (you are reading the file <code>/dev/user</code>).</p>

<p>Change into your home directory by entering <code>&quot;cd&quot;</code> with
no arguments (note that Inferno, unlike Unix, does not understand the tilde
character <code>&tilde;</code> to represent your home directory).  If you get a message
like <code>&quot;cd: /usr/Jon: '/usr/Jon' does not exist&quot;</code> then you
haven't created this user; see step 5 in the section &quot;Installing Inferno&quot;.</p>

<h2>Basic commands</h2>
<p>Many commands in Inferno have direct equivalents in Unix:</p>
<ul>
<li>To list the files in the current directory, use the <code>ls</code> command.
To see the details of the files, enter <code>ls –l</code>.  To see the file list
formatted more nicely, enter <code>lc</code>.  Your home directory (on a new
installation) should contain three directories and a file: <code>charon/ keyring/
lib/ namespace</code>.  When using the <code>lc</code> command, directories are designated by
a slash after the name.</li>
<li>To change the current directory, use the <code>cd</code> command.</li>
<li>To copy a file, use the <code>cp</code> command, and to move or rename a
file, use <code>mv</code>.</li>
<li>To delete a file use <code>rm</code>.</li>
<li>To find information about a command or application, use the <code>man</code>
command (e.g. <code>&quot;man cp&quot;</code>).  To view the output one page at
a time, pipe the output to <code>p</code>, the pager command: <code>&quot;man cp
| p&quot;</code>.  Use the enter key to move to the next page.</li>
<li>To read a file, use <code>cat</code> (e.g. <code>&quot;cat /LICENCE | p&quot;</code>
or <code>&quot;cat /dev/user&quot;</code>).</li>
<li>To output a string to the terminal, use <code>echo</code> (e.g. <code>&quot;echo
hello world&quot;</code>).  To output without the trailing newline use <code>&quote;echo –n.&quot;</code></li>
<li>To write to a file (creating a new one if it doesn’t exist), use the<code>&gt;</code>
operator, e.g. <code>&quot;echo hello world &gt; hello.txt&quot;</code>.  To
append to a file, use <code>&gt;&gt;</code>, e.g. <code>&quot;echo from mars &gt;&gt;
hello.txt&quot;.</code></li>
</ul>
<p>An important command is <code>os</code>, which runs a program in the host
operating system.  For example, on Unix, type <code>&quot;os uname&quot;</code>.
This runs the uname program, captures its output and prints the results on the
Inferno console (the result is the name of the host OS).  On Windows, try
<code>&quot;os ipconfig&quot;</code>, which will output the details of your
network connection(s).  The output from the executable can be piped into Inferno
programs and vice-versa.  For example, on Windows, the command <code>&quot;os ipconfig | wc&quot;</code>
will count the lines, words and characters in the output from the Windows program
<code>ipconfig</code>, using the Inferno program <code>wc</code>.</p>

<h2>GUI Applications</h2>
<p>You are not restricted to command-line interaction with Inferno.  Type
<code>&quot;wm/wm&quot;</code> at the command prompt and a graphical desktop
environment will appear:</p>

<img src="images/InfernoDesktop.jpg"/>

<p>Click on the Vita Nuova logo in the bottom left to bring up the menu shown
in this picture (the equivalent of Windows’ Start menu).  Note that the window
cannot be resized!  If you want a bigger window, set the environment variable
<code>EMU</code> to <code>&quot;-r&lt;inferno root&gt; -g1024x768&quot;</code>
and restart Inferno.  You can set the window to any size with the <code>–g</code> switch.</p>

<p>In the menu, click on Charon to launch the built-in web browser.
This is rather basic, but functional.  Play around with it.  Close Charon and
launch the Manual program from the &quot;Start menu&quot;.  This displays the
same information as the man command-line program but in a friendlier way.</p>

<p>The Inferno desktop is not designed as a replacement for Windows, KDE or any
other heavyweight environment.  Rather, it’s a lightweight container for simple
GUI apps.  These apps are written in Limbo, Inferno’s own programming language
which uses a variant of Tk for graphical interfaces. <em>TODO: say more about
Limbo somewhere</em></p>

<p>Launch a shell window from the &quot;Start menu&quot;.  This gives you the
same environment that you had from the command line.  You can open as many shell
windows as you like.  Close each shell window by clicking the X in the top
right-hand corner.  This also kills any programs that have been started from this
window.  You can cut and paste within and between shell windows by using the
middle mouse button (or scroll wheel).  Note that &quot;Snarf&quot; essentially
means &quot;Copy&quot;.  If your mouse only has two buttons... get a three-button 
one (or one with a clickable scroll wheel)!  It makes life an awful lot easier.</p>

<p>The Send command is particularly useful.  Select a piece of text anywhere in
the shell window (e.g. a previous command), click and hold the middle mouse
button over it, highlight the word “Send” and release the middle button.
The text will be copied and pasted at the command prompt and Enter is pressed
for you.  In other words, the text you selected will be entered as a command.</p>

<h2>Key Inferno concepts</h2>
<p>Before we go any further, we should go through some key concepts of Inferno.
It is these concepts that make Inferno such a good system for distributed computing.</p>

<h3>Everything looks like a file</h3>
<p>The most important concept in Inferno is that everything is virtualised as a
file or set of files.  We’ve already seen an example of this when we read the
<code>/dev/user</code> file to get the name of the current user (see &quot;Basic
Inferno&quot; above).  By contrast, other operating systems represent the current
user name as an environment variable.  Another example is that the current time
can be found by reading the <code>/dev/time</code> file (with the command 
<code>&quot;cat /dev/time&quot;</code>).  It is the logical extension of
Unix's metaphors of representing devices such as serial ports (<code>/dev/ttyS0</code>,
etc) and the mouse (<code>dev/mouse</code>) as files.  The important thing to
realise is that this representation of everything as a file does not mean that
everything <em>is</em> a file, in the sense of bytes on a hard disk.</p>

<p>Therefore, to interact with devices and programs in the Inferno world, we
read from and write to files.  This design replaces the more typical method of
using APIs (Application Programming Interfaces) to interface with systems.
The problem with the API approach is that it is essentially unbounded; there
could be any number of API functions for a device.  In contrast, the number of
possible file operations are very small (<em>TODO: reference Styx stuff here</em>).</p>

<h3>Namespaces</h3>
<p>A hierarchy of files in an Inferno system is called a <em>namespace</em>.
It is similar to a &quot;filesystem&quot; except that not all of the files in
an Inferno namespace need be literal files on the hard disk.  For example, the
namespace for a digital camera might look like this:</p>
<blockquote>
<pre>
       /   (The root of the namespace)
       |
 -----------
 |         |
ctl      images/
</pre>
</blockquote>
<p>The <code>ctl</code> file is a special file (a <em>synthetic</em> file) that
the user uses to send commands to the camera.  For example, to take a picture,
the user might enter the command <code>&quot;echo snap &gt; ctl&quot;</code>
(this writes the word &quot;snap&quot; to the <code>ctl</code> file).  The resulting
image can then be read from the <code>images/</code> directory.</p>

<h3>Mounting remote namespaces</h3>
<p>To get access to namespaces exposed by remote system, we use the <code>mount</code>
command.  This is very similar in principle to Unix’s <code>mount</code> command;
we specify what we want to mount and where in our own namespace we want to mount
it.  For example, if the namespace for the digital camera in the previous section
was hosted on a computer called <code>camera.somewhere.com</code> on port 1234,
we would enter the command <code>&quot;mount tcp!camera.somewhere.com!1234 /n/remote&quot;</code>.
Then the namespace of the camera would appear in the <code>/n/remote</code>
directory of our system.  We could then take a picture using the remote camera by issuing the
command <code>&quot;echo snap &gt; /n/remote/ctl&quot;</code>.  We shall try
some more examples of the mount command later in this tutorial. (<em>TODO: shall we?</em>)</p>

<h3>No difference between local and remote files</h3>
<p>You may have noticed from the last paragraph that once we had mounted the
remote camera’s namespace, we didn’t need to tell the echo command that
<code>/n/remote/ctl</code> actually represented a <em>remote</em> file. This is because,
in Inferno, applications do not know the difference between local and remote
files.  They use the same method for communicating with both.  The applications
simply send out messages and the operating system directs the messages to the
correct destination.  The protocol for these messages is called Styx.</p>

<h3>The Styx protocol</h3>
<p><em>(TODO: overhaul this section in light of JStyx?)</em> All communications
between Inferno systems, local and remote, are carried out using the
Styx protocol (TODO: ref something).  Because all messages are file operations
(since everything in the Inferno/Styx world is a file),
the Styx protocol has a very small command set (only 13 commands).  You can
probably guess many of the common commands: open, close, read, write, create
and delete.  Most users will not need to know anything at all about Styx.
Styx is an open protocol, and implementations are available (or can
be written fairly easily) for several languages, including Java (REF JStyx).
Therefore, an application does not have to run within Inferno to communicate
with an Inferno system – it just has to be able to &quot;speak&quot; Styx.</p>

<h3>The Limbo programming language</h3>
<p>Applications in Inferno are written in Limbo, a C-like language that has
native support for concurrent programming.  Limbo programs are guaranteed to be
portable across all installations of Inferno, with no exceptions.  You'll
probably be glad to know that you won’t need to learn anything about Limbo to
go through this tutorial.  (<em>TODO: ref some further reading?</em>).  Remember
that you can run native programs in the host operating system using the <code>os</code>
command (see &quot;Basic commands&quot; above); this is what we'll mainly be
doing in this tutorial. (<em>TODO: will we?</em>)</p>

</body>
</html>